package com.zjl.algorithm.dynamicprogramming;

/**
 * 钢条切割问题
 *
 * @author zhangjlk
 * @date 2025/11/29 21:05
 */
public class CutRodProblem {

    /**
     * 钢条切割问题 (完全背包解法)
     * * @param values 价格表。values[0] 代表长度为 1 的价格，values[1] 代表长度为 2 的价格...
     * @param n      钢条的总长度 (背包容量)
     * @return       最大能卖出的价格
     */
    static int cut(int[] values, int n) {
        // ---------------------------------------------------------
        // 1. 定义 DP 表
        // ---------------------------------------------------------
        // 为了让下标 i 直接代表 "长度 i"。比如 i=1 就代表长度1。
        // 这样 dp[0][...] 就代表 "逻辑上的第0行" (没有可选长度时)，
        // Java 默认初始化 int 数组全为 0，这刚好符合 Base Case：
        // "没有长度可选时，价值为0" 以及 "钢条长度为0时，价值为0"。
        // 所以这里不需要写那个 for 循环去手动填 0。
        int[][] dp = new int[values.length + 1][n + 1];

        // ---------------------------------------------------------
        // 2. 外层循环：遍历"物品" (切割长度 i)
        // ---------------------------------------------------------
        // i 从 1 开始，表示尝试切长度为 1, 2, 3... 的段
        for (int i = 1; i <= values.length; i++) {

            // 取出当前长度 i 对应的价格 v
            // 注意：values 数组是从下标 0 开始的，所以长度 i 对应 values[i-1]
            int v = values[i - 1];

            // ---------------------------------------------------------
            // 3. 内层循环：遍历"背包" (当前钢条总长度 j)
            // ---------------------------------------------------------
            for (int j = 1; j <= n; j++) {

                // 核心判断：当前钢条长度 j 是否够切一刀长度 i？
                if (j >= i) {
                    // 状态转移方程：取最大值
                    // 选项 A (dp[i-1][j]):
                    //      不切长度 i。直接继承上一行的结果 (只用之前更短的策略)。
                    // 选项 B (v + dp[i][j - i]):
                    //      收益 = 当前价格 v + 剩下的长度 (j-i) 继续用策略 i 切。
                    //      注意：这里查的是 dp[i] (当前行)，因为完全背包允许重复切。
                    //      注意：这里减去的是 i (长度/重量)，绝对不能减 v (价格/价值)！
                    dp[i][j] = Math.max(dp[i - 1][j], v + dp[i][j - i]);
                } else {
                    // 长度不够切，只能不切，继承上一行
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[values.length][n];
    }
}
